#!/usr/bin/env groovy

// Expose properties for a parameterized build
properties(
    [
        buildDiscarder(
            logRotator(
                artifactDaysToKeepStr: '',
                artifactNumToKeepStr: '',
                daysToKeepStr: '',
                numToKeepStr: '1000')),
        [
            $class: 'ParametersDefinitionProperty',
            parameterDefinitions: [
                [
                    name: 'TARGET_NODE',
                    description: 'Jenkins agent node',
                    $class: 'hudson.model.StringParameterDefinition',
                    defaultValue: 'container'
                ],
                [
                    name: 'GITHUB_BASE',
                    description: 'Github base for repos',
                    $class: 'hudson.model.ChoiceParameterDefinition',
                    choices: [
                        "git@github.com:markllama",
                    ].join("\n"),
                    defaultValue: 'git@github.com:markllama'
                ],
                [
                    name: 'SSH_KEY_ID',
                    description: 'SSH credential id to use',
                    $class: 'hudson.model.ChoiceParameterDefinition',
                    choices: [
                        "markllama-redhat",
                    ].join("\n"),
                    defaultValue: 'markllama-redhat'
                ],
                [
                    name: 'BUILD_VERSION',
                    description: 'OCP Version to build',
                    $class: 'hudson.model.ChoiceParameterDefinition',
                    choices: "3.10\n3.9\n3.8\n3.7\n3.6\n3.5\n3.4\n3.3",
                    defaultValue: '3.10'
                ],
                [
                    name: 'BUILD_MODE',
                    description: '''
release                   {ose,origin-web-console,openshift-ansible}/release-X.Y ->  https://mirror.openshift.com/enterprise/enterprise-X.Y/<br>
pre-release               {origin,origin-web-console,openshift-ansible}/release-X.Y ->  https://mirror.openshift.com/enterprise/enterprise-X.Y/<br>
online:int                {origin,origin-web-console,openshift-ansible}/master -> online-int yum repo<br>
online:stg                {origin,origin-web-console,openshift-ansible}/stage -> online-stg yum repo<br>
''',
                    $class: 'hudson.model.ChoiceParameterDefinition',
                    choices: [
                        "release",
                        "pre-release",
                        "online:int",
                        "online:stg"
                    ].join("\n")
                ],
                [
                    name: 'SIGN',
                    description: 'Sign RPMs with openshifthosted?',
                    $class: 'hudson.model.BooleanParameterDefinition',
                    defaultValue: false
                ],
                [
                    name: 'MOCK',
                    description: 'Mock run to pickup new Jenkins parameters?',
                    $class: 'hudson.model.BooleanParameterDefinition',
                    defaultValue: false
                ],
                [
                    name: 'TEST',
                    description: 'Run as much code as possible without pushing / building?',
                    $class: 'hudson.model.BooleanParameterDefinition',
                    defaultValue: true
                ],
                [
                    name: 'MAIL_LIST_SUCCESS',
                    description: "Who to tell things are good",
                    $class: 'hudson.model.StringParameterDefinition',
                    defaultValue: "markllama@redhat.com"
                ],
                [
                    name: 'MAIL_LIST_FAILURE',
                    description: "Who to tell things are good",
                    $class: 'hudson.model.StringParameterDefinition',
                    defaultValue: "markllama@redhat.com"
                ],
            ]
        ],
        disableConcurrentBuilds()
    ]
)

IS_TEST_MODE = TEST.toBoolean()
BUILD_VERSION_MAJOR = BUILD_VERSION.tokenize('.')[0].toInteger() // Store the "X" in X.Y
BUILD_VERSION_MINOR = BUILD_VERSION.tokenize('.')[1].toInteger() // Store the "Y" in X.Y
SIGN_RPMS = SIGN.toBoolean()

def get_mirror_url(build_mode, version) {
    if (build_mode == "online:int") {
        return "https://mirror.openshift.com/enterprise/online-int"
    }
    if (build_mode == "online:stg") {
        return "https://mirror.openshift.com/enterprise/online-stg"
    }
    return "https://mirror.openshift.com/enterprise/enterprise-${version}"
}

def mail_success(buildlib, version, mirrorURL, record_log) {

    def target = "(Release Candidate)"

    if (BUILD_MODE == "online:int") {
        target = "(Integration Testing)"
    }

    if (BUILD_MODE == "online:stg") {
        target = "(Stage Testing)"
    }

    def inject_notes = ""
    if (SPECIAL_NOTES.trim() != "") {
        inject_notes = "\n***Special notes associated with this build****\n${SPECIAL_NOTES.trim()}\n***********************************************\n"
    }

    def timing_report = get_build_timing_report(record_log)
    def image_list = get_image_build_report(record_log)

    def oa_changelog = get_rpm_changelog(buildlib, record_log, "openshift-ansible")

    PARTIAL = " "
    exclude_subject = ""
    if (BUILD_EXCLUSIONS != "") {
        PARTIAL = " PARTIAL "
        exclude_subject = " [excluded images: ${BUILD_EXCLUSIONS}]"
    }

    image_details = """${timing_report}
Images:
  - Images have been pushed to registry.reg-aws.openshift.com:443     (Get pull access [1])
    [1] https://github.com/openshift/ops-sop/blob/master/services/opsregistry.asciidoc#using-the-registry-manually-using-rh-sso-user
${image_list}
"""

    mail_list = MAIL_LIST_SUCCESS
    if (!BUILD_CONTAINER_IMAGES) {
        PARTIAL = " RPM ONLY "
        image_details = ""
        // Just inform key folks about RPM only build; this is just prepping for an advisory.
        mail_list = MAIL_LIST_FAILURE
    }

    mail(
        to: "${mail_list}",
        from: "markllama+jenkins@redhat.com",
        subject: "[aos-cicd] New${PARTIAL}build for OpenShift ${target}: ${version}${exclude_subject}",
        body: """\
OpenShift Version: v${version}
${inject_notes}
RPMs:
    Puddle (internal): http://download-node-02.eng.bos.redhat.com/rcm-guest/puddles/RHAOS/AtomicOpenShift/${BUILD_VERSION}/${OCP_PUDDLE}
    Exernal Mirror: ${mirrorURL}/${OCP_PUDDLE}
${image_details}

Brew:
  - Openshift: ${OSE_BREW_URL}

Jenkins job: ${env.BUILD_URL}

Are your Atomic OpenShift changes in this build? Check here:
https://github.com/openshift/ose/commits/v${NEW_VERSION}-${NEW_RELEASE}/

===Atomic OpenShift changelog snippet===
${OSE_CHANGELOG}


Are your OpenShift Ansible changes in this build? Check here:
https://github.com/openshift/openshift-ansible/commits/openshift-ansible-${NEW_VERSION}-${NEW_RELEASE}/

===OpenShift Ansible changelog snippet===
${oa_changelog}
""");

    try {
        if (BUILD_EXCLUSIONS == "" && BUILD_CONTAINER_IMAGES) {
            timeout(3) {
                sendCIMessage(messageContent: "New build for OpenShift ${target}: ${version}",
                              messageProperties: """build_mode=${BUILD_MODE}
                          puddle_url=${mirrorURL}/${OCP_PUDDLE}
                          image_registry_root=registry.reg-aws.openshift.com:443
                          brew_task_url_openshift=${OSE_BREW_URL}
                          product=OpenShift Container Platform
                          """,
                              messageType: 'ProductBuildDone',
                              overrides: [topic: 'VirtualTopic.qe.ci.jenkins'],
                              providerName: 'Red Hat UMB'
                )
            }
        }
    } catch (mex) {
        echo "Error while sending CI message: ${mex}"
    }
}

// extract timing information from the record_log and write a report string
// the timing record log entry has this form:
// image_build_metrics|elapsed_total_minutes={d}|task_count={d}|elapsed_wait_minutes={d}|
def get_build_timing_report(record_log) {
    metrics = record_log['image_build_metrics']

    if (metrics == null || metrics.size() == 0) {
        return ""
    }

    return """
Images built: ${metrics[0]['task_count']}
Elapsed image build time: ${metrics[0]['elapsed_total_minutes']} minutes
Time spent waiting for OSBS capacity: ${metrics[0]['elapsed_wait_minutes']} minutes
"""
}

// get the list of images built
def get_image_build_report(record_log) {
    builds = record_log['build']

    if ( builds == null ) {
        return ""
    }

    Set image_set = []
    for (i = 0; i < builds.size(); i++) {
        bld = builds[i]
        if (bld['status'] == "0" && bld['push_status'] == "0") {
            image_spec_string =
                "${bld['image']}:${bld['version']}-${bld['release']}"
            image_set << image_spec_string
        }
    }

    return "\nImages included in build:\n    " +
        image_set.toSorted().join("\n    ")
}

// Search the RPM build logs for the named package
// extract the path to the spec file and return the changelog section.
def get_rpm_changelog(buildlib, record_log, package_name) {
    rpms = record_log['build_rpm']

    // find the named package and the spec file path
    specfile_path = null
    for (i = 0 ; i < rpms.size(); i++) {
        if (rpms[i]['distgit_key'] == package_name) {
            specfile_path = rpms[i]['specfile']
            break
        }
    }

    // if no matching package found, return an empty string
    if (specfile_path == null) {
        return ""
    }

    // read the spec file and extract the changelog
    return buildlib.read_changelog(specfile_path)
}

// Will be used to track which atomic-openshift build was tagged before we ran.
PREV_BUILD = null

node(TARGET_NODE) {

    checkout scm
    AOS_CD_JOBS_COMMIT_SHA = sh(
        returnStdout: true,
        script: "git rev-parse HEAD",
    ).trim()

    //    def commonlib = load("pipeline-scripts/commonlib.groovy")
    //    commonlib.initialize()

    def buildlib = load("pipeline-scripts/buildlib.groovy")
    buildlib.initialize()
    echo "Initializing build: #${currentBuild.number} - ${BUILD_VERSION}.?? (${BUILD_MODE})"

    // oit_working must be in WORKSPACE in order to have artifacts archived
    OIT_WORKING = "${WORKSPACE}/oit_working"
    //Clear out previous work
    sh "rm -rf ${OIT_WORKING}"
    sh "mkdir -p ${OIT_WORKING}"

    PREV_BUILD = sh(returnStdout: true, script: "brew latest-build --quiet rhaos-${BUILD_VERSION}-rhel-7-candidate atomic-openshift | awk '{print \$1}'").trim()

    stage("enterprise-images repo") {
        buildlib.initialize_enterprise_images_dir()
    }

    stage("ose repo") {
        master_spec = buildlib.initialize_ose()
        // If the target version resides in ose#master
        IS_SOURCE_IN_MASTER = (BUILD_VERSION == master_spec.major_minor)
    }

    stage("origin-web-console repo") {
        sh "go get github.com/jteeuwen/go-bindata"
        buildlib.initialize_origin_web_console()
        dir(WEB_CONSOLE_DIR) {
            // Enable fake merge driver used in our .gitattributes
            sh "git config merge.ours.driver true"
            // Use fake merge driver on specific directories
            // We will be re-generating the dist directory, so ignore it for the merge
            sh "echo 'dist/** merge=ours' >> .gitattributes"
        }
    }

    stage("origin-web-console-server repo") {
        /**
         * The origin-web-console-server repo/image was introduced in 3.9.
         */
        USE_WEB_CONSOLE_SERVER = false
        if (BUILD_VERSION_MAJOR == 3 && BUILD_VERSION_MINOR >= 9) {
            USE_WEB_CONSOLE_SERVER = true
            buildlib.initialize_origin_web_console_server_dir()
            if (BUILD_MODE == "online:stg") {
                WEB_CONSOLE_SERVER_BRANCH = "stage"
            } else {
                WEB_CONSOLE_SERVER_BRANCH = "enterprise-${BUILD_VERSION_MAJOR}.${BUILD_VERSION_MINOR}"
            }
            dir(WEB_CONSOLE_SERVER_DIR) {
                sh "git checkout ${WEB_CONSOLE_SERVER_BRANCH}"
            }
        }
    }

    stage("analyze") {
        dir(env.OSE_DIR) {

            if (IS_SOURCE_IN_MASTER) {
                if (BUILD_MODE == "release") {
                    error("You cannot build a release while it resides in master; cut an enterprise branch")
                }
            } else {
                if (BUILD_MODE != "release" && BUILD_MODE != "pre-release") {
                    error("Invalid build mode for a release that does not reside in master: ${BUILD_MODE}")
                }
            }

            if (IS_SOURCE_IN_MASTER) {
                if (BUILD_MODE == "online:stg") {
                    OSE_SOURCE_BRANCH = "stage"
                    UPSTREAM_SOURCE_BRANCH = "upstream/stage"
                    sh "git checkout -b stage origin/stage"
                } else {
                    OSE_SOURCE_BRANCH = "master"
                    UPSTREAM_SOURCE_BRANCH = "upstream/master"
                }
            } else {
                OSE_SOURCE_BRANCH = "enterprise-${BUILD_VERSION}"
                if (BUILD_MODE == "release") {
                    // When building in release mode, no longer pull from upstream
                    UPSTREAM_SOURCE_BRANCH = null
                } else {
                    UPSTREAM_SOURCE_BRANCH = "upstream/release-${BUILD_VERSION}"
                }
                // Create the non-master source branch and have it track the origin ose repo
                sh "git checkout -b ${OSE_SOURCE_BRANCH} origin/${OSE_SOURCE_BRANCH}"
            }

            echo "Building from ose branch: ${OSE_SOURCE_BRANCH}"

            spec = buildlib.read_spec_info("origin.spec")
            rel_fields = spec.release.tokenize(".")

            if (! spec.version.startsWith("${BUILD_VERSION}.")) {
                // Looks like pipeline thinks we are building something we aren't. Abort.
                error("Expected version consistent with ${BUILD_VERSION}.* but found: ${spec.version}")
            }


            if (BUILD_MODE == "online:int" || BUILD_MODE == "online:stg") {
                /**
                 * In non-release candidates, we need the following fields
                 *      REL.INT.STG
                 * REL = 0    means pre-release,  1 means release
                 * INT = fields used to differentiate online:int builds
                 * STG = fields used to differentiate online:stg builds
                 */

                while (rel_fields.size() < 3) {
                    rel_fields << "0"    // Ensure there are enough fields in the array
                }

                if (rel_fields[0].toInteger() != 0) {
                    // Don't build release candidate images this way since they can't wind up
                    // in registry.access with a tag OCP can pull.
                    error("Do not build released products in ${BUILD_MODE}; just build in release or pre-release mode")
                }

                if (rel_fields.size() != 3) { // Did we start with > 3? That's too weird to continue
                                             error("Unexpected number of fields in release: ${spec.release}")
                }

                if (BUILD_MODE == "online:int") {
                    rel_fields[1] = rel_fields[1].toInteger() + 1  // Bump the INT version
                    rel_fields[2] = 0  // If we are bumping the INT field, everything following is reset to zero
                }

                if (BUILD_MODE == "online:stg") {
                    rel_fields[2] = rel_fields[2].toInteger() + 1  // Bump the STG version
                }

                NEW_VERSION = spec.version   // Keep the existing spec's version
                NEW_RELEASE = "${rel_fields[0]}.${rel_fields[1]}.${rel_fields[2]}"

                // Add a bumpable field for OIT to increment for image refreshes (i.e. REL.INT.STG.BUMP)
                NEW_DOCKERFILE_RELEASE = "${NEW_RELEASE}.0"

            } else if (BUILD_MODE == "release" || BUILD_MODE == "pre-release") {

                /**
                 * Once someone sets the origin.spec Release to 1, we are building release candidates.
                 * If a release candidate is released, its associated images will show up in registry.access
                 * with the tags X.Y.Z-R  and  X.Y.Z. The "R" cannot be used since the fields is bumped by
                 * refresh-images when building images with signed RPMs. That is, if OCP tried to load images
                 * with the X.Y.Z-R' its RPM was built with, the R != R' (since R' < R) and the image
                 * would not be found.
                 * For release candidates, therefore, we must only use X.Y.Z to differentiate builds.
                 *
                 * Note that this problem does not affect online:int & online:stg builds since we control the
                 * tags in the registries. We have refresh-images bump a harmless field in the release and then
                 * craft a tag in the registry [version]-[release] which does not include that bumped field.
                 */
                if (rel_fields[0].toInteger() != 1) {
                    error("You need to set the spec Release field to 1 in order to build in this mode")
                }

                // Undertake to increment the last field in the version (e.g. 3.7.0 -> 3.7.1)
                ver_fields = spec.version.tokenize(".")
                ver_fields[ver_fields.size() - 1] = "${ver_fields[ver_fields.size() - 1].toInteger() + 1}"
                NEW_VERSION = ver_fields.join(".")
                NEW_RELEASE = "1"
                NEW_DOCKERFILE_RELEASE = NEW_RELEASE

            } else {
                error("Unknown BUILD_MODE: ${BUILD_MODE}")
            }

            rpmOnlyTag = ""
            if (!BUILD_CONTAINER_IMAGES) {
                rpmOnlyTag = " (RPM ONLY)"
            }
            currentBuild.displayName = "#${currentBuild.number} - ${NEW_VERSION}-${NEW_RELEASE} (${BUILD_MODE}${rpmOnlyTag})"
        }
    }

    stage("prep web-console") {
        dir(WEB_CONSOLE_DIR) {
            // Unless building for stage, origin-web-console#entperise-X.Y should be used
            if (BUILD_MODE == "online:stg") {
                WEB_CONSOLE_BRANCH = "stage"
                sh "git checkout -b stage origin/stage"
            } else {
                WEB_CONSOLE_BRANCH = "enterprise-${spec.major_minor}"
                sh "git checkout -b ${WEB_CONSOLE_BRANCH} origin/${WEB_CONSOLE_BRANCH}"
                if (IS_SOURCE_IN_MASTER) {

                    // jwforres asked that master *not* merge into the 3.8 branch.
                    if (BUILD_VERSION != "3.8") {
                        sh """
                                # Pull content of master into enterprise branch
                                git merge master --no-commit --no-ff
                                # Use grunt to rebuild everything in the dist directory
                                ./hack/install-deps.sh
                                grunt build

                                git add dist
                                git commit -m "Merge master into enterprise-${BUILD_VERSION}" --allow-empty
                            """

                        if (!IS_TEST_MODE) {
                            sh "git push"
                        }
                    }

                }
            }

            // Clean up any unstaged changes (e.g. .gitattributes)
            sh "git reset --hard HEAD"
        }
    }

    stage("prep web-console-server") {
        if (BUILD_MODE != "online:stg" && USE_WEB_CONSOLE_SERVER && IS_SOURCE_IN_MASTER) {
            dir(WEB_CONSOLE_SERVER_DIR) {
                // Enable fake merge driver used in our .gitattributes
                sh "git config merge.ours.driver true"
                // Use fake merge driver on specific packages
                sh "echo 'pkg/assets/bindata.go merge=ours' >> .gitattributes"
                sh "echo 'pkg/assets/java/bindata.go merge=ours' >> .gitattributes"


                sh """
                            # Pull content of master into enterprise branch
                            git merge master --no-commit --no-ff
                            git commit -m "Merge master into enterprise-${BUILD_VERSION}" --allow-empty
                        """

                if (!IS_TEST_MODE) {
                    sh "git push"
                }

                // Clean up any unstaged changes (e.g. .gitattributes)
                sh "git reset --hard HEAD"
            }
        }
    }

    stage("merge origin") {
        dir(OSE_DIR) {
            // Enable fake merge driver used in our .gitattributes
            sh "git config merge.ours.driver true"
            // Use fake merge driver on specific packages
            sh "echo 'pkg/assets/bindata.go merge=ours' >> .gitattributes"
            sh "echo 'pkg/assets/java/bindata.go merge=ours' >> .gitattributes"

            if (UPSTREAM_SOURCE_BRANCH != null) {
                // Merge upstream origin code into the ose branch
                sh "git merge -m 'Merge remote-tracking branch ${UPSTREAM_SOURCE_BRANCH}' ${UPSTREAM_SOURCE_BRANCH}"
            } else {
                echo "No origin upstream in this build"
            }
        }
    }

    stage("merge web-console") {

        // In OCP release < 3.9, web-console is vendored into OSE repo
        TARGET_VENDOR_DIR = OSE_DIR
        if (USE_WEB_CONSOLE_SERVER) {
            // In OCP release > 3.9, web-console is vendored into origin-web-console-server
            TARGET_VENDOR_DIR = WEB_CONSOLE_SERVER_DIR
        }

        dir(TARGET_VENDOR_DIR) {

            // Vendor a particular branch of the web console into our ose branch and capture the SHA we vendored in
            // TODO: Is this necessary? If we don't specify a GIT_REF, will it just use the current branch
            // we already setup?
            // TODO: Easier way to get the VC_COMMIT by just using parse-rev when we checkout the desired web console branch?
            VC_COMMIT = sh(
                returnStdout: true,
                script: "GIT_REF=${WEB_CONSOLE_BRANCH} hack/vendor-console.sh 2>/dev/null | grep 'Vendoring origin-web-console' | awk '{print \$4}'",
            ).trim()

            if (VC_COMMIT == "") {
                sh("GIT_REF=${WEB_CONSOLE_BRANCH} hack/vendor-console.sh 2>/dev/null")
                error("Unable to acquire VC_COMMIT")
            }

            // Vendoring the console will rebuild this assets, so add them to the commit
            sh """
                    git add pkg/assets/bindata.go
                    git add pkg/assets/java/bindata.go
                """

            if (USE_WEB_CONSOLE_SERVER && !IS_TEST_MODE) {
                sh "git commit -m 'bump origin-web-console ${VC_COMMIT}' --allow-empty"
                sh "git push"
            }
        }

    }

    stage("ose tag") {
        dir(OSE_DIR) {
            // Set the new version/release value in the file and tell tito to keep the version & release in the spec.
            buildlib.set_rpm_spec_version("origin.spec", NEW_VERSION)
            buildlib.set_rpm_spec_release_prefix("origin.spec", NEW_RELEASE)
            // Note that I did not use --use-release because it did not maintain variables like %{?dist}

            commit_msg = "Automatic commit of package [atomic-openshift] release [${NEW_VERSION}-${NEW_RELEASE}]"
            if (!USE_WEB_CONSOLE_SERVER) {
                // If vendoring web console into ose, include the VC_COMMIT information in the ose commit
                commit_msg = "${commit_msg} ; bump origin-web-console ${VC_COMMIT}"
            }

            sh "git commit --allow-empty -m '${commit_msg}'" // add commit to capture our change message
            sh "tito tag --accept-auto-changelog --keep-version --debug"
            if (!IS_TEST_MODE) {
                sh "git push"
                sh "git push --tags"
            }
            OSE_CHANGELOG = buildlib.read_changelog("origin.spec")
        }
    }

    if (IS_TEST_MODE) {
        error("This is as far as the test process can proceed without triggering builds")
    }

    record_log = buildlib.parse_record_log(OIT_WORKING)
    mail_success(buildlib, NEW_FULL_VERSION, mirror_url, record_log)
}

