// Test OCP auto mode
properties(
    [
        buildDiscarder(
            logRotator(
                artifactDaysToKeepStr: '5',
                artifactNumToKeepStr: '10',
                daysToKeepStr: '5',
                numToKeepStr: '10')),
        [
            $class: 'ParametersDefinitionProperty',
            parameterDefinitions: [
                [
                    name: 'TARGET_NODE',
                    description: 'Jenkins agent node',
                    $class: 'hudson.model.StringParameterDefinition',
                    defaultValue: 'container'
                ],
                [
                    name: 'BUILD_VERSION',
                    description: 'The version to try to build',
                    $class: 'hudson.model.StringParameterDefinition',
                    defaultValue: 'latest'
                ],
                [
                    name: 'SSH_KEY_ID',
                    description: 'SSH credential id to use',
                    $class: 'hudson.model.ChoiceParameterDefinition',
                    choices: [
                        "markllama-aos-cd-bot",
                        "markllama"
                    ].join("\n"),
                    defaultValue: 'markllama-aos-cd-bot'
                ],
            ]
        ],
        disableConcurrentBuilds()
    ]
)

def get_branches(repo_url, pattern="") {

    branch_text = sh(
        returnStdout: true,
        script: [
            "git ls-remote ${repo_url} ${pattern}",
            "awk '{print \$2}'",
            "cut -d/ -f3"
        ].join(" | ")
    ).trim()

    return branch_text.split("\n")
}

def get_single_file(owner, repo_name, file_name, repo_token) {
    // Get a single file from a Github repository.

    auth_header = "Authorization: token " + repo_token
    file_url = "https://api.github.com/repos/${owner}/${repo_name}/contents/${file_name}"
    accept_header = "Accept: application/vnd.github.v3.raw"

    query = "curl --silent -H '${auth_header}' -H '${accept_header}' -L ${file_url}"
    content = sh(
	returnStdout: true,
	script: query
    )

    return content
}

def checkout_repo(repo_url, repo_path) {
    sh(
        "git clone ${repo_url} ${repo_path}"
    )
}

// Matcher is not serializable; use NonCPS
@NonCPS
def extract_rpm_version( spec_content ) {
    def ver_matcher = spec_content =~ /Version:\s*([.0-9]+)/
    if ( ! ver_matcher ) { // Groovy treats matcher as boolean in this context
        error( "Unable to extract Version field from RPM spec" )
    }
    return ver_matcher[0][1]
}

// Matcher is not serializable; use NonCPS
@NonCPS
def extract_rpm_release_prefix(spec_content ) {
    def rel_matcher = spec_content =~ /Release:\s*([.a-zA-Z0-9+-]+)/  // Do not match vars like %{?dist}
    if ( ! rel_matcher ) { // Groovy treats matcher as boolean in this context
        error( "Unable to extract Release field from RPM spec" )
    }
    return rel_matcher[0][1]
}

node(TARGET_NODE) {

    ose_repo_url = "git@github.com:markllama/ose.git"

    github_auth_token = readFile("/jenkins/agent/.ssh/github-token-oauth.txt").trim()
    
    stage("startup") {
        echo "building ${BUILD_VERSION}"
    }

    sshagent([SSH_KEY_ID]) {
        stage("get release branches") {
            branches = get_branches(ose_repo_url, "enterprise-*")
            echo "found branches: ${branches}"
        }

	stage("get master spec file") {
	    spec_file = get_single_file("openshift", "ose", "origin.spec", github_auth_token)
	    echo spec_file
	}

	stage("extract version-release") {
	    master_version = extract_rpm_version(spec_file)
	    echo "Master version: ${master_version}"
	}
	
	// get version and release
        //stage("checkout repo") {
        //    checkout_repo(
        //        ose_repo_url,
        //        "ose"
        //    )
        //}
    }
}
